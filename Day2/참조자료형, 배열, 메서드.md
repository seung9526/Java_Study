```
🫧 참조 자료형

배열(array), 클래스(class), 인터페이스(interface) 등이 있음

배열이란?
동일한 자료형을 묶어 저장하는 참조 자료형, 생성할 때 크기를 지정, 한 번 크기를 지정하면 절대 변경할 수 없음

배열 생성하기
1. 배열선언
자료형[] 변수명, 자료형 변수명[]

배열을 선언하면 스택 메모리에 변수의 공간만 생성하고, 공간의 안은 비운 채로 둔다. 
그 이유는 아직 배열의 실제 데이터인 객체를 생성하지 않았기 때문이며 스택 메모리에 위치하고 있는 
참조 자료형 변수의 빈공간을 초기화 할 때는 null 값을 사용할 수 있으며 
null 값은 힙 메모리의 위치(번지)를 가리키고 있지 않다는 의미이다. 

즉 이말은 연결된 실제 데이터가 없다는 것을 의미한다.

2. 힙 메모리에 배열의 객체 생성
모든 참조 자료형의 실제 데이터(객체)는 힙 메모리에 생성, 힙 메모리에 객체를 생성하기 위해서는 new 키워드를 생성

new 자료형[배열의 길이]

3. 배열 자료형 변수에 객체 대입하기
변수 선언과 값(참조 자료형은 객체)의 대입을 한 번에 작성해도 되고, 따로 구분해 작성해도 된다. 

자료형[] 변수명 = new 자료형[배열의 길이];

자료형[] 변수명;
변수명 = new 자료형[배열의 길이];

스택 메모리 공간은 값을 초기화하지 않으면 빈 공간으로 존재 한다는 것이다. 
반면 힙 메모리는 어떤 상황에서도 빈 공간이 존재하지 않는다. 
그래서 값을 주지 않으면 컴파일러가 값을 강제로 초기화 한다. 
기본 자료형일 때 숫자는 모두 0(실수는0.0), 불리언은 false 로 값이 초
기화되며 이외에 모든 참조 자료형은 null로 초기화 된다. 

객체의 위치를 참조 변수에 저장하는 이유?
new 키워드를 이용해 객체를 생성하면 자바 가상 머신은 힙 메모리 내에 비어 있는 공간에 객체를 생성한다. 
힙 메모리에 비어 있는 공간은 그때그때 다를 것이므로 객체가 생성 될 때마다 다른 위치에 저장될 수 있다. 
따라서 자바 가상 머신이 생성한 객체의 위치를 반드시 알아야 개발자가 해당 객체를 사용할 수 있다.

4. 객체에 값 입력하기
배열은 값을 저장할 수 있는 공간마다 방 번호가 있는데, 이 번호를 인덱스(index)라고 한다. 
인덱스는 0부터 시작하며, 1씩 증가한다.

참조 변수명[인덱스(index)] = 값;


🫧 1차원 배열을 생성하는 다양한 방법
1. 배열 객체를 생성하고 값 대입하기

자료형[] 참조 변수명 = new 자료형[배열의 길이];
참조 변수명[0] = 값;
참조 변수명[1] = 값;
...
참조 변수명[배열의 길이 -1] = 값;

2. 배열 객체 생성과 함께 값 대입하기
배열 객체를 생성함과 동시에 값을 대입하는 것이다.

자료형[] 참조 변수명 = new 자료형[]{값, 값, ... , 값};

3. 대입할 값만 입력하기
new 키워드 없이 초기화 할 값만 중괄호에 넣어 대입하는 것이다.

자료형[] 참조 변수명 = {값, 값, ... , 값};


🫧 참조 변수와 배열 객체의 값 초기화 하기
기본 자료형 변수이든, 참조 자료형 변수이든 모든 변수는 스택 메모리에 위치하고 있음, 
따라서 모든 변수는 초기화 이후 출력가능.

int a;	// 기본 자료형
int[] b;	// 참조 자료형
System.out.print(a);	// 오류 발생
System.out.print(b);	// 오류 발생

기본 자료형의 초기값으로는 '값', 참조 자료형의 초기값으로는 'null'을 사용하면 된다.

🫧 참조 자료형으로서 배열의 특징
기본 자료형은 스택 메모리에 실제 데이터값을 저장하고 있으므로 기본 자료형 변수를 복사하면 실제 데이터값이 1개 더 복사되며
이후 복사된 값을 아무리 변경해도 원본 값은 아무런 영향을 받지 않는다.

🫧 반복문을 이용해 배열 데이터 읽기
배열의 모든 데이터를 출력하려면 배열의 길이만큼 출력해야 하며 반복의 횟수를 결정하기 위해서는 먼저 배열의 길이를 알아야 한다.
물론 배열을 생성할 때 길이가 결정되므로 그 길이만큼 반복문을 수행하면 된다. 
그래서 자바에서는 '배열 참조변수.length'로 배열의 길이를 구할 수 있는 방법을 제공한다. 

여기서 포인트 연산자(.)는 '해당 참조 변수가 가르키는 곳으로 가라'라는 의미이다.

배열 참조 변수.length

for-each 문을 사용하는 방법도 존재하며 for-each 문은 배열이나 컬렉션 등의
집합 객체에서 원소들을 하나씩 꺼내는 과정을 반복하는 구문으로, 집합 객체의 원소들을 출력할 때 사용.

for(원소 자료형 변수명 : 집합 객체) {
}

배열의 각 원소 값을 출력하는 마지막 방법은 Arrays 클래스의 toString() 정적 메서드를 사용하는 것.

🫧 2차원 정방 행렬 배열
가로 및 세로 방향의 2차원으로 데이터를 저장하는 배열이 2차원 배열이며 2차원 배열을 선언할 때도 배열을 대괄호([])로 표시

자료형[][] 변수명, 자료형 변수명[][], 자료형[] 변수명[]

'메모리는 2차원 데이터를 바로 저장할 수 없다' 배열의 첫 번째 특징은 동일한 자료형만 묶어 자장할 수 있다는 것이였고
2차원 배열의 각각의 행이 1차원 배열이므로 '2차원 배열은 1차원 배열을 원소로 포함하고 있는 1차원 배열'이라고 생각할 수 있음.

1. 배열 객체의 행 성분부터 생성하고 열 성분 생성하기
자료형[][] 참조 변수명 = new 자료형[행의 길이][열의 길이];
참조 변수명[0][0] = 값;
참조 변수명[0][1] = 값;

참조 변수명[행의 길이 -1][열의 길이-1] = 값;


2. 배열 객체의 행 성분부터 생성하고 열 성분 생성하기
자료형[][] 참조 변수명 = new 자료형[행의 길이];
참조 변수명[0] = 1차원 배열의 생성;
참조 변수명[1] = 1차원 배열의 생성;

참조 변수명[행의 길이 -1] = 1차원 배열의 생성;


3. 배열의 자료형과 함께 대입할 값 입력하기

자료형[][] 참조 변수명 = new 자료형[][]{{값, 값, ..., 값}, ..., {값, 값, ..., 값}};

4. 대입할 값만 입력하기

자료형[][] 참조 변수명 = [][]{{값, 값, ..., 값}, ..., {값, 값, ..., 값}};

🫧 2차원 비정방 행렬 배열
비정방 행렬은 각 행마다 열의 길이가 다른 2차원 배열을 의미. 
2차원 비정방 행렬 배열의 객체를 생성하는 방법은 3가지이다.

1. 배열 객체의 행 성분부터 생성하고 열 성분 생성하기
자료형[][] 참조 변수명 = new 자료형[행의 길이][];	//열의 길이는 표시하지 않음.
참조 변수명[0] = 1차원 배열의 생성;
참조 변수명[1] = 1차원 배열의 생성;

참조 변수명 [행의 길이-1] = 1차원 배열의 생성;

2. 자료형과 대입할 값만 입력하기
자료형과 함께 이중 중괄호를 사용해 생성할 때 초깃값을 넘겨 주는 것. 
대괄호 안에 행렬의 크기를 넣지 않으며, 초깃값에 따라 각 행마다 들어갈 배열의 길이가 결정

자료형[][] 참조 변수명 = new 자료형[][] {{값, 값, ..., 값} ...,{값, 값, ..., 값}};

3. 대입할 값만 입력하기
초기값만 이중 중괄호에 넣어 대입

자료형[][] 참조 변수명 = {{값, 값, ..., 값}, ..., {값, 값, ..., 값}};

int[][] b; 
b = {{1,2}, {3,4,5}};	// (X)

🫧 2차원 배열의 출력
2차원 배열은 가로, 세로 방향으로 데이터가 분포되어 있어 2개의 인덱스를 사용한다. 
따라서 2차원 배열의 모든 데이터를 출력하기 위해서는 기본적으로 이중 for문을 사용해야 한다.

int[][] a = {{1,2}, {3,4,5}};

for(int i=0; i<a.length; i++){
	for(int j=0; j<a[i].length; j++){
		System.out.print(a[i][j]);
		}
	}

이중 for-each 문을 사용할 경우

int[][] a = {{1,2}, {3,4,5}};

for(int[] m: a){
	for(int[] n : m){
		System.out.print(n);
		}
	}
	
🫧 main() 메서드의 입력매개변수
public static void main(String[] args){
	// 여기서 String[] : 여러 개의 String 객체를 묶어 저장하는 문자열 배열
}

타입 변환 메서드
- 문자열 → 정수 : Integer.parseInt(문자열)
- 문자열 → 실수 : Double.parseDouble(문자열)
- 정수 → 문자열 : String.valueOf(정수)
- 실수 → 문자열 : String.valueOf(실수)

🫧 문자열을 저장하는 String(문자열의 표현과 객체 생성)

String 참조 변수명 = new String("문자열");

String 참조 변수명 = "문자열";

🫧 String 클래스의 2가지 특징
한번 정의 된 문자열은 변경할 수 없다. ( 객체 안의 값을 변경하면 새로운 객체를 생성 )
문자열 리터럴을 바로 입력해 객체를 생성할 때 같은 문자열 끼리 객체를 공유
- new로 생성할 때는 동일한 문자열 객체가 힙 메모리에 있든, 없는 무조건 새롭게 객체를 생성.
- 문자열 리터럴로 생성할 때는 힙 메모리에 리터럴로 생성된 동일 문자열을 포함하고 있는 객체가 있으면 그 객체를 공유

🫧 String 클래스의 주요 메서드
문자열 길이 : return type = int, method = length()

문자열 검색 : return type = char, method = charAt(int index), 인덱스 위치에서의 문자
             return type = int, method = indexOf(int ch),
                                         indexOf(int ch, int fromIndex),
                                         indexOf(String str),
                                         indexOf(String str, String fromIndex),
                                        문자열에 포함된 문자 또는 문자열의 위치를 앞에서부터 검색했을 때 
                                        일치하는 인덱스 값(fromIndex는 검색 시작 위치)
	
                               method = lastIndexOf(int ch),
                                        lastIndexOf(int ch, int fromIndex),
                                        lastIndexOf(String str),
                                        lastIndexOf(String str, int fromIndex),
                                        문자열에 포함된 문자 또는 문자열의 위치를 뒤에서부터 검색했을 때 
                                        일치하는 인덱스 값(fromIndex는 검색 시작 위치)
										
문자열 변환 및 검색 : return type = float, method = String.valueOf(boolean b),
                                                  String.valueOf(char c),
                                                  String.valueOf(int i),
                                                  String.valueOf(long l),
                                                  String.valueOf(float f),
                                                  String.valueOf(double d),
                                                  boolean, char, int, long, float, double 
                                                  값을 문자열로 변환하기 위한 정적 메서드
                                                  
                    return type = double, method = concat(String str), 문자열 연결(String 객체의 + 연산과 동일)
                    
문자열 배열 전환 : return type = byte[], method = getBytes(),
                                                 getBytes(charset charset),
                                                 문자열을 byte[]로 변환(변환할 때 문자 셋(charset) 지정 가능)
											
간단히 정리자면
- length() : 문자열의 길이를 리턴
- charAt() : 문자열에서 특정 인덱스에 위치해 있는 문자를 알아 낸다.
- indexOf() : 문자열에서 특정 문자열을 앞에서 부터 찾아 위칫값을 알아낸다.
- lastIndexOf() : 문자열에서 특정 문자나 특정 문자열을 뒤에서부터 찾아 위칫값을 알아낸다.
- String.valueOf() : 기본 자료형을 문자열로 바꾸는 정적 메서드이다.
- concat() : 2개의 문자열을 연결한다. + 연산자와 동일한 기능을 수행
- getBytes() : 문자열을 byte 배열로 변환한다. 자바 입출력 과정에서 주로 사용
- toCharArray() : 문자열을 char 배열로 변환한다. 자바 입출력 과정에서 주로 사용

문자열 수정 : return type = Stirng, method = toLowerCase(), 영문 문자를 모두 소문자로 변환
                                   method = toUpperCase(), 영문 문자를 모두 대문자로 변환
                                   method = replace(char oldChar, char newChar), oldChar 문자열을 newChar 문자열로 대체한 문자열 생성
                                   method = substring(int beginIndex), beginIndex 부터 끝까지의 문자열 생성
                                            substring(int beginIndex, int endIndex),
                                            beginIndex 부터 endIndex-1 위치까지의 문자열 생성
										
             return type = String[], method = split(String regex),
                                     method = split(String regex, int limit),
                                     regex를 기준으로 문자열을 분할한 문자열 배열을 생성
                                     (regex 구분 기호는 '|' 기호로 여러 개 사용 가능, limit는 분할의 최대 개수)
	
              return type = String, method = trim(), 문자열의 앞뒤 공백 제거
              
              문자열 내용 비교 : return type = boolean, method = equals(), 
                               문자열의 실제 내용 비교(==는 메모리 번지(stack) 비교)

             return type = boolean, method = equalsIgnoreCase(String anotherString), 
                                             대소문자 구문 없이 무자열의 실제 내용 비교
			
위의 내용 간단히 정리 하면		
- toLowerCase() : 영문 문자를 모두 소문자로 변환
- toUpperCase() : 영문 문자를 모두 대문자로 변환
- replace() : 일부 문자열을 다른 문자열로 대체
- substring() : 문자열의 일부만을 포함하는 새로운 문자열 객체를 생성
- split() : 특정 기호를 기준으로 문자열을 분리
- trim() : 문자열의 좌우 공백을 제거
- equals() : 두 문자열의 위췻값이 아닌 실제 데이터값을 비교한다. 이때 대소문자를 구분한다.
- equalsIgnoreCase() : 두 문자열의 위칫값이 아닌 실제 데이터값을 비교한다. 이때 소문자를 구분하지 않는다.
```
