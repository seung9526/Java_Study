```
🫧 클래스의 상속의 개념과 문법적 특징
클래스의 상속은 부모 클래스의 멤버(필드, 메서드, 이너클래스)를 내려받아 자식 클래스 내부에 포함

⭐ UML 기호에서 화살표는 어느 방향으로 그려야 할까?
시스템을 모델로 표현해 주는 대표적 모델링 언어인 UML로 상속을 표시할 때는 
화살표를 부모 클래스 쪽으로 향하게 그린다. 
상속할 때 멤버들이 내려오는 방향이 부모에서 자식 클래스 쪽이므로 
화살표 방향이 반대라고 생각하기 쉬움.

🫧 상속의 장점
1. 코드의 중복성을 제거할 수 있다.
2. 클래스의 다형적 표현이 가능하다.
ex) 대학생과 직장인의 예로 설명하면
'대학생은 대학생이다'라는 말은 맞는 말이다.
' 대학생은 사람이다' 이것도 맞는 표현이다.

그러므로 이렇게 1개의 객체를 여러 가지 모양으로 표현할 수 있는 
특성을 다형성(polymorphism)이라 한다.

🫧 상속 문법
클래스 상속할 때는 extends 키워드를 사용하며,
클래스명 다음에 'extends 부모 클래스'를 표기
그러나 클래스는 다중상속이 불가능하다 그 이유는 허용하면 모호성 때문에

class 자식 클래스 extends 부모 클래스 {
	...
}

🫧 상속할 때의 메모리 구조
클래스 영역에는 선언된 자료형의 클래스와 그 부모 클래스가 모두 로딩된다. 
자바 가상 머신은 자식 클래스의 객체를 생성할 때 가장 먼저 부모 클래스의 객체를 생성.

🫧 생성자의 상속 여부
멤버는 클래스의 4가지 내부 구성요소 중 생성자를 제외한 
필드, 메서드, 이너 클래스를 말한다. 
생성자는 자식 클래스로 상속 되어서는 안된다.

class B extends A {
	A() {}	// 생성자? 또는 메서드?
}

부모 클래스로부터 생성자를 상송받는다면 상속과 송시에 오류가 발생할 것.

⭐ 생성자는 클래스명과 동일하고, 
  리턴 타입이 없이야 하며, 
  메서드는 반드시 리턴 타입을 포함해야 한다.

🫧 객체의 다형적 표현
상속 구조에서 자기 자신을 가리키거나 화살표 방향으로는 항상 다형적 표현을 할 수 있다. 
'A는 A이다.', 'B는 A이다.' 등은 모두 가능한 표현.

A a1 = new A();	// A는 A이다.
A a2 = new B();	// B는 A이다.


⭐ 자식 클래스를 부모 클래스로 부를 때는 '업 캐스팅'이라 한다.

🫧 객체의 업캐스팅과 다운 캐스팅
기본 자료형에서 업캐스팅은 범위가 좁은 쪽에서 넓은 쪽으로 캐스팅하는 것을 말하며, 
다운캐스팅은 그 반대. 

객체에서의 자식 클래스에서 부모 클래스 쪽으로 변환되는 것이 업캐스팅, 
그 반대는 다운 캐스팅.

하지만 업캐스팅은 컴파일러에서 개발자 대신 넣어주며 
다운캐스팅을 할 경우에는 개발자가 직접 명시적으로 넣어 줘야 한다.

⭐ 다운캐스팅은 컴파일러가 자동으로 추가하지 않으므로 등호를 중심으로 
좌우의 자료형이 동일하도록 명시적으로 캐스팅을 수행해야 문법오류가 발생하지 않는다.

캐스팅의 가능 여부는 무슨 타입으로 선언돼 있는지 중요하지 않으며 
어떤 생성자로 생성됐는 지가 중요 하며 선언된 타입이 의미하는 바는 
실제 객체에서 자신이 선언된 타입의 객체를 가리키게 되는 것.

🫧 캐스팅 가능 여부을 확인하는 instanceof 키워드
캐스팅 가능 여부를 불리언 타입으로 확인할 수 있게 instanceof를 제공

참조 변수 instanceof 타입	// true : 캐스팅 가능 / false : 캐스팅 불가능

여기서 instanceof 뒤의 타입은 참조 변수가 표현될 수 있는 모든 다형적 타입을 의미

🫧 메서드 오버라이딩의 개념과 동작
메서드 오버라이딩(overriding) : 부모 클래스에게 상속받은 메서드와 동일한 
               이름의 메서드를 재정의하는 것으로, 부모의 메서드를 자신이 만든 메서드로 
               덮어쓰는 개념이며 오버라이딩을 수행되기 위해서는 다음 2가지 조건을 만족해야한다.

- 부모 클래스의 메서드와 시그니처 및 리턴타입이 동일해야 한다.
- 부모 클래스의 메서드보다 접근 지정자의 범위가 같거나 넓어야 한다.

⭐ 오버라이딩은 덮어쓰기와 똑같은 개념인가?
덮어쓰기와 오버라이딩은 차이가 있다. 
덮어쓰기는 이전 파일이 완전히 삭제되고, 새로운 파일로 바뀌는 것. 
반면 오버라이딩은 이전의 print() 메서드 위에 
새로운 메서드가 올라(over) 타고(riding) 있다고 생각하면 된다.

⭐ 동일한 필드나 메서드가 있을 때는 무엇부터 실행하나?
객체 내에 동일한 필드 또는 동일한 메서드가 있을 때 
참조 변수가 가리키는 객체의 바깥쪽부터 안쪽으로 들어가면서 만나는 첫 번째 멤버가 실행

🫧 메서드 오버로딩
오버로딩(overloading) : 이름은 동일하지만, 시그니처가 다른 
                여러 개의 메서드를 같은 공간에 정의하는 것을 말함

🫧 메서드 오버라이딩과 접근 지정자
메서드 오바라이딩할 때 사용할 수 있는 접근 지정자
public 일때 public
protected 일때  public, protected
default 일때 public, protected, default
private 일때 public, protected, default, private


🫧 인스턴스 필드의 중복
class A {
	int m = 3;
}

class B extends A {
	int m = 4;
}

메서드의 경우 객체 내의 메서드 위치를 저장하는 공간은 분리돼 있지만, 
실제 메서드가 저장되는 공간은 인스턴스 메서드 영역 한곳이므로 오버라이딩이 발생하는 것.

🫧 정적 필드의 중복
정적(static) 필드의 저장 공간은 정적 영역의 클래스 내부에 만들어지고, 모든 객체가 공유한다. 

class A {
	static int m = 3;
}

class B extends A {
	static int m = 4;
}

ex)
// A 객체를 생성하지 않고 필드값 지정
A.m = 3;    

// A 객체를 생성한 후 필드값 지정
A a = new A();
a.m = 3;

// A, B 객체를 생성하지 않고 필드값 지정
A.m = 3;
B.m = 4; 	

// B 객체를 A 타입으로 지정한 후 필드값 지정
A ab = new B();
ab.m = 3;

// A, B 객체를 생성하지 않고 필드값 지정
A.m = 3;
B.m = 4;

// B 객체를 A 타입으로 지정한 후 필드값 지정
A ab = new B();
ab.m = 3;

🫧 정적 메서드의 중복
인스턴스 메서드가 오버라이딩됐던 이유는 동일한 공간에 
동일한 이름의 메서드를 저장했기 때문이다. 

하지만 정적 메서드는 정적 필드와 마찬가지로 각자의 클래스 내부에 존재

class A {
	static void print(){
		System.out.print("A");
	}
}

class B extends A {
	static void print(){
		System.out.print("B");
	}
}

// 클래스명으로 바로 접근
A.print();
B.print();

// 객체 생성
A aa = new A();
B bb = new B();
A ab = new B();

// 객체를 통한 메서드 호출
aa.print()
bb.print()
ab.print();

🫧 인스턴스 멤버와 정적 멤버의 중복 정리
인스턴스 필드 : 오버라이딩 (X)
인스턴스 메서드 : 오버라이딩 (O) -> 메서드 오버라이딩
정적 필드 : 오버라이딩 (X)
정적 메서드 : 오버라이딩 (X)

A               a = new   B();
기준점                     인스턴스 메서드
인스턴스 필드
정적 필드
정적 메서드

여기서 기준점은 '값을 읽을 때의 기준'을 의미.


🫧 부모의 객체를 가리키는 super 키워드
super 키워드는 부모의 객체를 가리키는 것으로, 
필드명의 중복 또는 메서드 오버라이딩으로 가려진 부모의 필드
또는 메서드를 호출하기 위해 사용한다.

🫧 부모 클래스의 생성자를 호출하는 super() 메서드
super()는 부모 클래스의 생성자를 호출한다. 
this()와 마찬가지로 생성자의 내부에서만 사용할 수 있고, 
반드시 첫줄에 와야 한다. 

그리고 this()메서드와 super()메서드는 1개의 생성자에서 절대로 같이 쓸 수 없음.


🫧 최상위 클래스 Object
아무런 클래스로 상속하지 않으면 자동으로 extends Object를 삽입해 Object클래스를 상속

🫧 Object 클래스의 주요 메서드
return type : String             method name = toString()
                                Object 객체의 정보 패키지.클래스명@해시코드
	                             일반적으로 오버라이딩해서 사용

return type : boolean            method name = equals(Object obj)
                                 입력매개변수 obj 객체와 stack 메모리값(번지) 비교
                                 등가 비교 연산자 == 와 동일한 결과

return type : int                method name = hashCode()
                                 객체의 hashCode() 값 리턴, Hashtable, HashMap 등의 동등 비교에 사용
                                 위칫값을 기반으로 생성된 고유 값
								 
return type : void               method name = wait()
                                               wait(long timeout)
                                               wait(long timeout, int nanos)
                                               현재의 쓰레드를 일시정지 상태로 전환
                                               보통 notify() 또는 notifyAll()로 일시정지 해제
                                               동기화 블록에서만 사용 가능
								                
                                method name = notify()
                                              notifyAll()
                                      wait()를 이용해 일시정지 상태의 1개의 쓰레드(notify()) 
                                      또는 전체 쓰레드(notifyAll())의 일지정지 해제
                                      동기화 블록에서만 사용가능

```
