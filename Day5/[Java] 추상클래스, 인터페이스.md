```
📝 추상 클래스와 인터페이스

🫧 추상클래스의 정의
추상 메서드 : 메서드의 본체가 완성되지 않은 미완성 메서드를 말하며 
메서드의 기능을 정의하는 중괄호 안이 비어 있다는 것이 아니라 중괄호 자체가 없으며, 
중괄호가 없기 때문에 명령어의 끝을 알리는 세미콜론(;)으로 끝나야 함.

abstract 리턴 타입 메수드명(입력매개변수);

ex) abstract void abc();

추상 메서드를 1개 이상 포함하고 있는 클래스는 반드시 추상 클래스로 정의돼야 한다. 
일반적으로 추상 클래스는 메서드의 기능이 정의돼 있지 않은 미완성 메서드가 1개 이상 있다는 의미

abstract class 클래스명{
}

⭐ 메서드의 완성 기준?
abstract class A{
	abstract void abc();    // 추상 메서드는 미완성 메서드
}

class B extends A {
	void abc() {
		// 중괄호 안에 아무런 코드가 없어도 완성된 메서드
	}
}

🫧 추상 클래스의 특징
객체를 직접 생성할 수 없다.

⭐ 힙 메모리에는 값이 비어 있는 필드가 저장 될 수 없으므로 
초기화하지 않은 필드를 힙 메모리에 저장하려고하 하면 강제로 값을 초기화 한다. 
하물며 미완성 형태의 메서드는 당연히 힙 메모리에 포함될 수 없는 것이다.

용어 정리
완성된 메서드이든, 미완성된 메서드이든 부모에게 상속받은 메서드를 
자식 클래스에서 재정의하는 것을 통칭해 '오버라이딩(overriding)'이라 한다. 
이 중 부모에게 물려받은 미완성 메서드를 자식 클래스에서 완성하는 것을 
특별히 '구현한다(implements)'라고 말한다.

⭐ 추상 클래스 안에는 반드시 추상 메서드가 포함돼야 할까?
결론 부터 이야기 하면 그럴 필요는 없다. 
즉, 내부에 모두 완성된 메서드, 
즉 일반 메서드만 존재해도 추상클래스로 정의할 수 있다. 
하지만 추상 클래스로 정의하면 객체를 직접 생성하지 못하는 제약 조건이 있으므로 
멀쩡한 클래스를 추상 클래스로 정의할 이유가 없는 것.

🫧 추상 클래스 타입의 객체 생성 방법
1. 추상 클래스를 일반 클래스로 상속해 객체 생성
abstract class A {
	abstract void abc();     // A a = new A(); (x)
}

class B extends A {
	void abc(){
		// A a = new B(); (O)
		// B b = new B(); (O)
	}
}

2. 익명 이너 클래스
컴파일러가 내부적으로 추상 클래스를 상속해 메서드 오버라이딩을 수행한 클래스를 생성하고, 
그 클래스로 객체를 생성하는 방법. 
이때 내부적으로 생성된 클래스명은 전혀 알 수 없으므로 
개발자의 입장에서는 익명(이름이 없는) 클래스가 되는 것.

클래스명 참조 변수명 = new 생성자(){
    // 추상 메서드의 오버라이딩
	void abc(){
	}
};

⭐ 익명 이너 클래스 방법은 추상 클래스나 인터페이스뿐 아니라 완성되니 
메서드만 포함하는 일반 클래스를 상속받아 메서드를 추가하거나 재정의하는 데도 사용할 수 있다.

즉, 딱 한 번만 만들어 사용할 객체가 있을 때는 
익명 이너 클래스를 활용하는 것이 훨씬 간결한 코드를 작성하는데 도움을 준다.


🫧 인터페이스 정의와 특징
인터페이스는 내부의 모든 필드가 public static final로 정의되고, 
static과 default 메서드 이외의 모든 메서드는 
public abstract로 정의된 객체지향 프로그래밍 요소다. 
class 대신 interface 키워드를 사용해 선언

interface 인터페이스명 {
	public static final 자료형 필드명 = 값;
	public abstract 리턴 타입 메서드명();
}

🫧 인터페이스의 상속
클래스가 클래스를 상속할 때는 extends를 사용한 반면, 
클래스가 인터페이스를 상속할 때는 implements 키워드를 사용. 
상속에 있어서 인터페이스의 가장 큰 특징은 다중 상속이 가능하다는 것이다. 
1개의 클래스가 여러 개의 인터페이스를 상속할 때 쉼표(,)로 구분해 나열;

클래스명 implements 인터페이스명, ..., 인터페이스명{
	// 내용
}

클래스와 인터페이스를 동시에 상속하는 구조
클래스명 extends 클래스명 implements 인터페이스명, ..., 인터페이스명 {
	// 내용
}

🫧 인터페이스 타입의 객체 생성 방법
인터페이스도 추상 메서드를 초함하고 있으므로 객체를 직접 생성할 수는 없음. 
이때는 추상 클래스와 마찬가지로 자식 클래스를 정의하고, 
자식 클래스의 생성자로 객체를 생성하는 방법과 
익명 이너 클래스를 이용해 바로 객체를 생성하는 방법을 사용할 수 있다.

1. 인터페이스를 일반 클래스로 상속해 객체 생성
interface A {
	int a = 3;
	void abc();
}

class B implements A{
	public void abc(){
		// A a = new B();
		// B b = new B();
	}
}

2. 익명 이너 클래스 사용
A a = new A(){
	public void abc(){
		// 미완성 메서드를 완성한 후 A 객체 생성
	}
};

🫧 인터페이스의 필요성
1. 다중 상속의 제약 해결
2. 코드의 재사용과 일관성
3. 다형성 지원
4. 코드의 결합도 감소
5. 테스트와 유지 보수의 용이성

🫧 디폴트 메서드와 정적 메서드
1. 인터페이스 내에 완성된 메서드인 디폴트(default) 메서드가 포함 될 수 있다.

interface 인터페이스명 {
	public default 리턴 타입 메서드명{
		//내용
	}
}

2. 자식 클래스에서 부모 인터페이스의 디폴트 메서드 호출 방법
부모 인터페이스명.super.디폴트 메서드명

3. 인터페이스 내의 정적 메서드 호출
인터페이스명.정적 메서드명

```
